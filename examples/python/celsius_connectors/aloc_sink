#!/usr/bin/env python3

import asyncore
import asynchat
import random
import re
import socket
import struct
import sys
import time
import traceback

# NOTES:
#
# 1. This server will truncate the out_path & out_path+".txnlog" files.
#    If you want to preserve their data, then move them out of the way
#    before starting this server.

from wallaroo.experimental import connector_wire_messages as cwm

def parse_abort_rules(path):
    a = []
    try:
        with open(path, 'rb') as f:
            for l in f:
                a.append(eval(l))
        return a
    except FileNotFoundError:
        return []

class AsyncServer(asynchat.async_chat, object):
    def __init__(self, handler_id, sock, out_path, abort_rule_path, streams=None):
        print("AsyncServer.__init__", handler_id, sock)
        self._id = handler_id
        self._conn = sock
        self._out_path = out_path
        self._out = open(self._out_path, 'ab')
        self._out_offset = self._out.tell()
        self._txn_log = open(self._out_path + ".txnlog", 'ab')
        self._abort_rule_path = abort_rule_path
        asynchat.async_chat.__init__(self, sock=self._conn)
        self.in_buffer = []
        self.out_buffer = []
        self.reading_header = True
        self.set_terminator(4) # first frame header
        self.in_handshake = True
        self._streams = {} if streams is None else streams
        self.received_count = 0
        self._reset_count = {}
        self._txn_state = {}
        self._txn_commit_next = True
        self._txn_stream_content = []
        self._txn_local_count = 0

        self._abort_rules = parse_abort_rules(self._abort_rule_path)
        for t in self._abort_rules:
            if t[0] == "stream-content":
                stream_id = t[1]
                regexp = t[2]
                self._txn_stream_content.append((stream_id, regexp))

    def collect_incoming_data(self, data):
        """Buffer the data"""
        self.in_buffer.append(data)

    def found_terminator(self):
        """Data is going to be in two parts:
        1. a 32-bit unsigned integer length header
        2. a payload of the size specified by (1)
        """
        if self.reading_header:
            # Read the header and set the terminator size for the payload
            self.reading_header = False
            h = struct.unpack(">I", b"".join(self.in_buffer))[0]
            self.in_buffer = []
            self.set_terminator(h)
        else:
            # Read the payload and pass it to _handle_frame
            frame_data = b"".join(self.in_buffer)
            self.in_buffer = []
            self.set_terminator(4) # read next frame header
            self.reading_header = True
            self._handle_frame(frame_data)

    def _handle_frame(self, frame):
        self.received_count += 1
        self.updated_received_count()
        msg = cwm.Frame.decode(frame)
        # Hello, Ok, Error, Notify, NotifyAck, Message, Ack, Restart
        self.count = 0
        if isinstance(msg, cwm.Hello):
            # As of 2019-03-04, Wallaroo's connector sink is not managing
            # credits and will rely solely on TCP backpressure for its
            # own backpressure signalling.
            ok = cwm.Ok(500, self._streams.values())
            self.write(ok)
        elif isinstance(msg, cwm.Notify):
            if msg.stream_id != 1:
                error = cwm.Error("Unsupported stream id {}".format(msg.stream_id))
                self.write(error)
                return
            # respond with notifyack
            try:
                por = self._streams[msg.stream_id][2]
            except:
                por = 0
            notify_ack = cwm.NotifyAck(
                True,
                msg.stream_id,
                por)
            self._streams[msg.stream_id] = [msg.stream_id,
                                            msg.stream_name,
                                            por]
            self.write(notify_ack)
        elif isinstance(msg, cwm.Message):
            self.handle_message(msg)
        elif isinstance(msg, cwm.Error):
            # Got error message from worker
            # close the connection and pass msg to the error handler
            print("Received an error message. closing the connection")
            self.close()
            raise Exception(msg.message)
        else:
            # write the original message back
            self.write(msg)

    def handle_message(self, msg):
        if msg.stream_id == 0:
            self.handle_message_stream0(msg)
        else:
            self.handle_message_streamx(msg)

    def handle_message_stream0(self, msg):
        msg2 = cwm.TwoPCFrame.decode(msg.message)
        if isinstance(msg2, cwm.ListUncommitted):
            uncommitted = list(self._txn_state.keys())
            uncommitted.append("doesnt.exist.txn.aborting-wont-hurt.-----0-0")
            reply = cwm.ReplyUncommitted(msg2.rtag, uncommitted)
            reply_bytes = cwm.TwoPCFrame.encode(reply)
            msg = cwm.Message(0, cwm.Message.Ephemeral, None, None, None, reply_bytes)
            self.write(msg)

            log = [time.time(), 'list-uncommitted', uncommitted]
            self._txn_log.write(bytes("{}\n".format(log).encode('utf-8')))
            self._txn_log.flush()
        elif isinstance(msg2, cwm.TwoPCPhase1):
            print('2PC: Phase 1 got {}'.format(msg2))
            print('2PC: Phase 1 txn_state = {}'.format(self._txn_state))

            # Sanity checks
            for (stream_id, start_por, end_por) in msg2.where_list:
                if stream_id != 1:
                    self._txn_commit_next = False
                    print('2PC: Phase 1 invalid stream_id {} in {}'
                        .format(stream_id, msg2))
                if start_por > end_por:
                    self._txn_commit_next = False
                    print('2PC: Phase 1 invalid start_por {} end_por {}'
                        .format(start_por, end_por))
                if end_por > self._out_offset:
                    self._txn_commit_next = False
                    print('2PC: Phase 1 invalid end_por {} file size {}'
                        .format(end_por, self._out.tell()))

            # Check local debugging/testing abort rules
            self._txn_local_count += 1
            for r in self._abort_rules:
                if r[0] == 'local-txn':
                    if self._txn_local_count == r[1]:
                        self._txn_commit_next = False
                        print('2PC: abort next transaction: local txn count {}'
                            .format(self._txn_local_count))
                elif r[0] == 'txnid-regexp':
                    if re.search(r[1], msg2.txn_id):
                        self._txn_commit_next = False
                        print('2PC: abort next transaction: regexp {} matches txn_id {}'
                            .format(r[1], msg2.txn_id))

            # TODO: fsync ... Too bad Python doesn't allow us to use fsync
            # without going around to the 'os' module.  We're going to skip
            # the fsync for now.

            success = self._txn_commit_next
            reply = cwm.TwoPCReply(str(msg2.txn_id).encode('utf-8'), success)
            reply_bytes = cwm.TwoPCFrame.encode(reply)
            msg = cwm.Message(0, cwm.Message.Ephemeral, None, None, None, reply_bytes)
            self.write(msg)

            self._txn_state[msg2.txn_id] = (success, msg2.where_list)
            if success:
                log_tag = '1-ok'
            else:
                log_tag = '1-rollback'
            log = [time.time(), log_tag, msg2.txn_id, msg2.where_list]
            self._txn_log.write(bytes("{}\n".format(log).encode('utf-8')))
            self._txn_log.flush()

            self._txn_commit_next = True
        elif isinstance(msg2, cwm.TwoPCReply):
            raise Exception("Bad stream ID 0 message: {}".format(msg2))
        elif isinstance(msg2, cwm.TwoPCPhase2):
            print('2PC: Phase 2 got {}'.format(msg2))
            print('2PC: Phase 2 txn_state = {}'.format(self._txn_state))
            if msg2.txn_id in self._txn_state:
                (phase1_status, where_list) = self._txn_state[msg2.txn_id]
                if not msg2.commit:
                    for (stream_id, start_por, end_por) in where_list:
                        if stream_id != 1:
                            raise Exception('Phase 2 abort: bad stream_id {}'.
                                format(stream_id))
                        print('2PC: truncating {} to offset {}'.format(self._out_path, start_por))
                        self._out.truncate(start_por)
                        self._out.flush()
                if not phase1_status and msg2.commit:
                    print('2PC: mute/unmute placeholder 1 @ aloc_sink')
                    print('2PC: Protocol error: phase 1 status was rollback but phase 2 says commit')
                    ##### time.sleep(1.0)
                    print('2PC: mute/unmute placeholder 2 @ aloc_sink')
                    sys.exit(66)

                if msg2.commit and phase1_status:
                    log_tag = '2-ok'
                else:
                    log_tag = '2-rollback'
                log = [time.time(), log_tag, msg2.txn_id, where_list]
                self._txn_log.write(bytes("{}\n".format(log).encode('utf-8')))
                self._txn_log.flush()

                del self._txn_state[msg2.txn_id]
                print('2PC: Phase 2 txn_state = {}'.format(self._txn_state))
            else:
                print('2PC: ERROR: Phase 2 got unknown txn_id {} commit {}'.format(msg2.txn_id, msg2.commit))
                log = [time.time(), '2-error', msg2.txn_id, msg2.commit]
                self._txn_log.write(bytes("{}\n".format(log).encode('utf-8')))
                self._txn_log.flush()
            # No reply is required for Phase 2
        else:
            raise Exception("Stream ID 0 not implemented, msg2 = {}".format(msg2))

    def handle_message_streamx(self, msg):
        bs = bytes(msg.message)
        ret1 = self._out.write(bs)
        ret2 = self._out.flush()

        if (len(bs) != ret1) or (ret2 != None):
            self._txn_commit_next = False
            raise Exception("File write error? {} != {} or {} != None".format(len(bs), ret1, ret2))

        for (stream_id, regexp) in self._txn_stream_content:
            if stream_id == msg.stream_id:
                if re.search(regexp, str(bs)):
                    self._txn_commit_next = False
                    print('2PC: abort next transaction: {} matches {}'
                        .format(regexp, bs))

        self._out_offset += len(msg.message)
        if msg.message_id:
            self._streams[msg.stream_id][2] = msg.message_id
        if msg.flags & cwm.Message.Eos:
            # ack eos
            print("NH: acking eos for {}".format(msg))
            self.write(cwm.Ack(credits = 1,
                               acks= [(msg.stream_id, self._streams[msg.stream_id][2])]))

    def write(self, msg):
        print("write {}".format(msg))
        data = cwm.Frame.encode(msg)
        super(AsyncServer, self).push(data)

    def updated_received_count(self):
        if self.received_count % 100 == 0:
            print("Sending ack for streams!")
            ack = cwm.Ack(
                credits = 10,
                acks = [
                    (sid, por) for sid, _, por in self._streams.values()])
            self.write(ack)
        if self.received_count % 200 == 0:
            # send a restart every 200 messages
            print('PERIODIC RESTART, what could possibly go wrong?')
            self.write(cwm.Restart())

    def handle_error(self):
        _type, _value, _traceback = sys.exc_info()
        traceback.print_exception(_type, _value, _traceback)

    def close(self):
        print("Closing the connection")
        print("last received id by stream:\n\t{}".format(
            "\n\t".join("{}, {}: {}".format(sid, sn, mid)
                      for sid, sn, mid in self._streams.values())))
        super(AsyncServer, self).close()
        log = [time.time(), 'connection-closed', True]
        self._txn_log.write(bytes("{}\n".format(log).encode('utf-8')))
        self._txn_log.flush()


class EchoServer(asyncore.dispatcher):

    def __init__(self, host, port, out_path, abort_rule_path):
        asyncore.dispatcher.__init__(self)
        self.create_socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind((host, port))
        self.listen(1)
        self._out_path = out_path
        self._abort_rule_path = abort_rule_path
        self.count = 0
        self._streams = {}

    def handle_accepted(self, sock, addr):
        print('Incoming connection from %s' % repr(addr))
        handler = AsyncServer(self.count, sock,
            self._out_path, self._abort_rule_path, self._streams)
        self.count += 1

out_path = sys.argv[1]
abort_rule_path = sys.argv[2]
print("out_path: ", out_path)
print ("abort_rule_path: ", abort_rule_path)
server = EchoServer('127.0.0.1', 7200, out_path, abort_rule_path)
print("server: ", server)
print("asyncore file: ", asyncore.__file__)
asyncore.loop(timeout=0.001)
